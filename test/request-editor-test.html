<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../mocha/mocha.js"></script>
    <script src="../../../chai/chai.js"></script>
    <script src="../../../wct-mocha/wct-mocha.js"></script>

    <!-- CodeMirror + modes loader -->
    <script src="../../../codemirror/lib/codemirror.js"></script>
    <script src="../../../codemirror/addon/mode/loadmode.js"></script>
    <script src="../../../codemirror/mode/meta.js"></script>
    <!--Default set of parsers, add as many as you need -->
    <script src="../../../codemirror/mode/javascript/javascript.js"></script>
    <script src="../../../codemirror/mode/xml/xml.js"></script>
    <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
    <!-- JSON linter -->
    <script src="../../../jsonlint/lib/jsonlint.js"></script>
    <script src="../../../codemirror/addon/lint/lint.js"></script>
    <script src="../../../codemirror/addon/lint/json-lint.js"></script>

  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <request-editor></request-editor>
      </template>
    </test-fixture>

    <test-fixture id="noUrl">
      <template>
        <request-editor no-url-editor></request-editor>
      </template>
    </test-fixture>

    <script type="module">
    import sinon from '../../../sinon/pkg/sinon-esm.js';
    import '../request-editor.js';
    suite('Defaults', function() {
      let element;
      suiteSetup(function(done) {
        element = fixture('basic');
        flush(() => done());
      });

      test('URL editor is visible by default', function() {
        const editor = element.shadowRoot.querySelector('url-input-editor');
        assert.ok(editor);
      });

      test('Fires request-data-changed custom event', function() {
        const spy = sinon.spy();
        element.addEventListener('request-data-changed', spy);
        console.log('SETTING URL');
        element.url = 'https://mulesoft.com';
        assert.isTrue(spy.calledOnce);
      });

      test('The request-data-changed custom event contains request data', function(done) {
        const URL = element.url = 'https://mulesoft.com';
        const HEADERS = element.headers = 'content-type: test';
        const METHOD = 'HEAD';
        const callback = function(e) {
          element.removeEventListener('request-data-changed', callback);
          assert.equal(e.detail.url, URL);
          assert.equal(e.detail.headers, HEADERS);
          assert.equal(e.detail.method, METHOD);
          assert.notOk(e.detail.payload, '');
          done();
        };
        element.addEventListener('request-data-changed', callback);
        element.method = METHOD;
      });

      // test('Computes query model property', function(done) {
      //   element.shadowRoot.querySelector('url-input-editor').detailsOpened = true;
      //   element.url = 'https://mulesoft.com?param=value&test=true';
      //   flush(() => {
      //     assert.typeOf(element.queryModel, 'array');
      //     assert.lengthOf(element.queryModel, 2);
      //     done();
      //   });
      // });

      test('collapseOpened is true by default', function() {
        assert.isTrue(element.collapseOpened);
      });
    });

    suite('_dispatch()', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });
      const eName = 'test-event';
      const eDetail = 'test-detail';
      test('Dispatches an event', () => {
        const spy = sinon.spy();
        element.addEventListener(eName, spy);
        element._dispatch(eName);
        assert.isTrue(spy.called);
      });
      test('Returns the event', () => {
        const e = element._dispatch(eName);
        assert.typeOf(e, 'customevent');
      });
      test('Event is cancelable by default', () => {
        const e = element._dispatch(eName);
        assert.isTrue(e.cancelable);
      });
      test('Event is composed', () => {
        const e = element._dispatch(eName);
        if (typeof e.composed !== 'undefined') {
          assert.isTrue(e.composed);
        }
      });
      test('Event bubbles', () => {
        const e = element._dispatch(eName);
        assert.isTrue(e.bubbles);
      });
      test('Event is not cancelable when set', () => {
        const e = element._dispatch(eName, eDetail, false);
        assert.isFalse(e.cancelable);
      });
      test('Event has detail', () => {
        const e = element._dispatch(eName, eDetail);
        assert.equal(e.detail, eDetail);
      });
    });

    suite('_sendGaEvent()', () => {
      let element;
      setup(() => {
        element = fixture('basic');
      });
      const action = 'test-action';
      test('Calls _dispatch()', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._sendGaEvent(action);
        assert.isTrue(spy.called);
      });
      test('Returns the event', () => {
        const e = element._sendGaEvent(action);
        assert.typeOf(e, 'customevent');
        assert.equal(e.type, 'send-analytics');
      });
      test('Event is not cancelable', () => {
        const e = element._sendGaEvent(action);
        assert.isFalse(e.cancelable);
      });
      test('Detail has action', () => {
        const e = element._sendGaEvent(action);
        assert.equal(e.detail.action, action);
      });
      test('Detail has category', () => {
        const e = element._sendGaEvent(action);
        assert.equal(e.detail.category, 'Request editor');
      });
      test('Detail has type', () => {
        const e = element._sendGaEvent(action);
        assert.equal(e.detail.type, 'event');
      });
    });

    suite('noUrlEditor', function() {
      let element;
      suiteSetup(function(done) {
        element = fixture('noUrl');
        flush(() => done());
      });

      test('URL editor is removed when noUrlEditor is set', function() {
        const editor = element.shadowRoot.querySelector('url-input-editor');
        assert.notOk(editor);
      });

      test('Hiding URL editor removes the URL value', function() {
        assert.isUndefined(element.url);
      });
    });

    suite('Tabs setup', function() {
      let element;
      suiteSetup(function() {
        element = fixture('basic');
      });

      test('Body is hidden for GET', function(done) {
        element.method = 'GET';
        flush(() => {
          const tab = element.shadowRoot.querySelectorAll('paper-tabs paper-tab')[1];
          assert.isTrue(tab.hasAttribute('hidden'));
          done();
        });
      });

      test('Body is hidden for HEAD', function(done) {
        element.method = 'HEAD';
        flush(() => {
          const tab = element.shadowRoot.querySelectorAll('paper-tabs paper-tab')[1];
          assert.isTrue(tab.hasAttribute('hidden'));
          done();
        });
      });

      test('Body is visible for POST', function(done) {
        element.method = 'POST';
        flush(() => {
          const tab = element.shadowRoot.querySelectorAll('paper-tabs paper-tab')[1];
          assert.isFalse(tab.hasAttribute('hidden'));
          done();
        });
      });
    });

    suite('toggle()', function() {
      let element;
      suiteSetup(function() {
        element = fixture('basic');
      });

      test('Closes the parameters editor', function() {
        element.toggle();
        assert.isFalse(element.collapseOpened);
      });

      test('Opens back the parameters editor', function() {
        element.toggle();
        assert.isTrue(element.collapseOpened);
      });

      test('Dispatches GA event', () => {
        const spy = sinon.spy(element, '_sendGaEvent');
        element.toggle();
        assert.isTrue(spy.called, '_sendGaEvent was called');
        assert.equal(spy.args[0][0], 'Toggle parameters');
        assert.typeOf(spy.args[0][1], 'string');
      });
    });

    suite('_computeToggleIconClass()', function() {
      let element;
      suiteSetup(function() {
        element = fixture('basic');
      });

      test('Always returns string', function() {
        const result = element._computeToggleIconClass();
        assert.typeOf(result, 'string');
      });

      test('Returns toggle-icon for falsy argument', function() {
        const result = element._computeToggleIconClass();
        assert.equal(result, 'toggle-icon');
      });

      test('Adds opened name for truily argument', function() {
        const result = element._computeToggleIconClass(1);
        assert.equal(result, 'toggle-icon opened');
      });
    });

    suite('_computeToggleLabel()', function() {
      let element;
      suiteSetup(function() {
        element = fixture('basic');
      });

      test('Always returns string', function() {
        const result = element._computeToggleLabel();
        assert.typeOf(result, 'string');
      });

      test('Returns \'show\' label for falsy argument', function() {
        const result = element._computeToggleLabel();
        assert.equal(result, 'Show panel');
      });

      test('Returns \'hide\' label for truily argument', function() {
        const result = element._computeToggleLabel(1);
        assert.equal(result, 'Hide panel');
      });
    });

    suite('_isPayloadChanged()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Changes selected tab', function(done) {
        element.method = 'PUT';
        element.selectedTab = 1;
        flush(() => {
          element._isPayloadChanged(false);
          assert.equal(element.selectedTab, 0);
          done();
        });
      });

      test('Do not changes selected tab if is payload', function(done) {
        element.method = 'PUT';
        element.selectedTab = 3;
        flush(() => {
          element._isPayloadChanged(true);
          assert.equal(element.selectedTab, 3);
          done();
        });
      });

      test('Do not changes selected tab if other tab is selected', function(done) {
        element.method = 'PUT';
        element.selectedTab = 3;
        flush(() => {
          element._isPayloadChanged(false);
          assert.equal(element.selectedTab, 3);
          done();
        });
      });
    });

    suite('notifyRequestChanged()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
        element.url = 'test-url';
        element.method = 'test-method';
        element.headers = 'test-headers';
      });

      test('Calls serializeRequest()', () => {
        const spy = sinon.spy(element, 'serializeRequest');
        element.notifyRequestChanged();
        assert.isTrue(spy.called);
      });

      test('Calls _dispatch()', () => {
        const spy = sinon.spy(element, '_dispatch');
        element.notifyRequestChanged();
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'request-data-changed');
        assert.typeOf(spy.args[0][1], 'object');
        assert.isUndefined(spy.args[0][2]);
      });
    });

    suite('_getHeaders()', () => {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Returns all headers', () => {
        element.headers = 'content-type: my/app\naccept: all\ncontent-length: 80';
        const result = element._getHeaders('GET');
        assert.equal(result, 'content-type: my/app\naccept: all\ncontent-length: 80');
      });

      test('Returns all headers for post', () => {
        element.ignoreContentOnGet = true;
        element.headers = 'content-type: my/app\naccept: all\ncontent-length: 80';
        const result = element._getHeaders('POST');
        assert.equal(result, 'content-type: my/app\naccept: all\ncontent-length: 80');
      });

      test('Filters headers for GET', () => {
        element.ignoreContentOnGet = true;
        element.headers = 'content-type: my/app\naccept: all\ncontent-length: 80';
        const result = element._getHeaders('GET');
        assert.equal(result, 'accept: all');
      });
    });

    suite('serializeRequest()', () => {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Returns an object', () => {
        const result = element.serializeRequest();
        assert.typeOf(result, 'object');
      });

      test('Sets empty url if missing', () => {
        const result = element.serializeRequest();
        assert.equal(result.url, '');
      });

      test('Sets editor url', () => {
        element.url = 'test-url';
        const result = element.serializeRequest();
        assert.equal(result.url, element.url);
      });

      test('Sets default method if missing', () => {
        element.method = '';
        const result = element.serializeRequest();
        assert.equal(result.method, 'GET');
      });

      test('Sets editor method', () => {
        element.method = 'test-method';
        const result = element.serializeRequest();
        assert.equal(result.method, element.method);
      });

      test('Sets default headers if missing', () => {
        element.headers = undefined;
        const result = element.serializeRequest();
        assert.equal(result.headers, '');
      });

      test('Sets editor headers', () => {
        element.headers = 'test-header';
        const result = element.serializeRequest();
        assert.equal(result.headers, element.headers);
      });

      test('Sets editor payload', () => {
        element.method = 'POST';
        element.payload = 'test-payload';
        const result = element.serializeRequest();
        assert.equal(result.payload, element.payload);
      });

      test('Calls _getHeaders() and sets headers property', () => {
        element.ignoreContentOnGet = true;
        element.headers = 'content-type: my/app\naccept: all\ncontent-length: 80';
        const result = element.serializeRequest();
        assert.equal(result.headers, 'accept: all');
      });

      test('Sets auth', (done) => {
        flush(() => {
          const panel = element.shadowRoot.querySelector('authorization-panel');
          panel.selected = 1;
          flush(() => {
            const authPanel = panel.shadowRoot.querySelector('auth-method-basic');
            authPanel.username = 'test-username';
            authPanel.password = 'test-password';
            flush(() => {
              const result = element.serializeRequest();
              assert.typeOf(result.auth, 'object');
              assert.equal(result.auth.type, 'basic');
              assert.equal(result.auth.settings.username, authPanel.username);
              assert.equal(result.auth.settings.password, authPanel.password);
              done();
            });
          });
        });
      });

      test('Sets responseActions', () => {
        element.responseActions = [{
          'source': 'request.body',
          'action': 'assign-variable',
          'enabled': true
        }];
        const result = element.serializeRequest();
        assert.deepEqual(result.responseActions, element.responseActions);
      });

      test('Sets requestActions', () => {
        element.requestActions = [{
          variables: [{
            enabled: true,
            value: 'test-value',
            variable: 'test-var'
          }]
        }];
        const result = element.serializeRequest();
        assert.deepEqual(result.requestActions, element.requestActions);
      });

      test('Sets queryModel', (done) => {
        element.url = 'https://mulesoft.com?param=value';
        flush(() => {
          element.shadowRoot.querySelector('url-input-editor').detailsOpened = true;
          const result = element.serializeRequest();
          assert.typeOf(result.queryModel, 'array');
          assert.lengthOf(result.queryModel, 1);
          done();
        });
      });
    });

    suite('_sendRequestInner()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Calls send()', function() {
        const spy = sinon.spy(element, 'send');
        const obj = {
          preventDefault: function() {},
          stopPropagation: function() {},
          composedPath: () => []
        };
        element._sendRequestInner(obj);
        assert.isTrue(spy.called);
      });

      test('Do not calls send() when it is the source', function() {
        const spy = sinon.spy(element, 'send');
        element._sendRequestInner({
          composedPath: () => [element],
          preventDefault: function() {},
          stopPropagation: function() {},
          target: element
        });
        assert.isFalse(spy.called);
      });
    });

    suite('Components configuration', () => {
      suite('api-headers-editor', () => {
        let element;
        setup(function(done) {
          element = fixture('basic');
          element.method = 'POST';
          flush(() => done());
        });

        [
          ['isPayload', true],
          ['allowCustom', true],
          ['allowDisableParams', true],
          ['allowHideOptional', true]
        ].forEach((item) => {
          test(`Has ${item[0]} set`, () => {
            const panel = element.shadowRoot.querySelector('api-headers-editor');
            assert.equal(panel[item[0]], item[1]);
          });
        });
      });
      suite('api-body-editor', () => {
        let element;
        setup(function(done) {
          element = fixture('basic');
          element.method = 'POST';
          flush(() => done());
        });

        [
          ['selected', 0],
          ['allowCustom', true],
          ['allowDisableParams', true],
          ['allowHideOptional', true]
        ].forEach((item) => {
          test(`Has ${item[0]} set`, () => {
            const panel = element.shadowRoot.querySelector('api-body-editor');
            assert.equal(panel[item[0]], item[1]);
          });
        });
      });
    });

    suite('_validateContentHeaders()', () => {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Returns false for non GET request', () => {
        const result = element._validateContentHeaders({
          method: 'POST'
        });
        assert.isFalse(result);
      });

      test('Returns false for non GET request', () => {
        const result = element._validateContentHeaders({
          method: 'POST'
        });
        assert.isFalse(result);
      });

      test('Returns false when no headers', () => {
        const result = element._validateContentHeaders({
          method: 'GET'
        });
        assert.isFalse(result);
      });

      test('Returns true when content-length header found', () => {
        const result = element._validateContentHeaders({
          method: 'GET',
          headers: 'accept: xxx\ncontent-length: 10'
        });
        assert.isTrue(result);
      });

      test('Uses default method', () => {
        const result = element._validateContentHeaders({
          headers: 'content-length: 10\naccept: xxx\n'
        });
        assert.isTrue(result);
      });
    });
    </script>
  </body>
</html>
